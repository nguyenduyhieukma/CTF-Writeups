from sage.all import *

def solve_cvp(B, t, verbose=False):
    """
    Approximately and efficiently solves the closest vector problem.

    Arguments:
        B: a matrix whose rows are the basis vectors.
        t: the target vector.
        verbose: if True, print out useful information while solving.

    Return:
        A vector in the lattice generated by `B` (approximately) closest to `t`.

    """
    #  perform vector projecting using the Gram-Schmidt process
    t_ = t - B.stack(t).gram_schmidt()[0].row(-1)
    if verbose:
        print "Target vector projection:"
        print numerical_approx(t_, digits=4)

    # apply the LLL algorithm
    B_ = B.LLL()
    if verbose:
        print "\nLLL-reduced basis:"
        print numerical_approx(B_, digits=4)

    # find the exact linear combination of vectors in `B_` that produces `t_`
    c = B_.solve_left(t_)

    # round each coefficient to its nearest integer
    c_ = vector(map(round, c))
    if verbose:
        print "\nRound-off errors:"
        print numerical_approx(vector(map(abs, c - c_)), digits=4)

    # calculate the result
    result = c_ * B_
    if verbose:
        print "\nDifference between target vector and result:"
        print numerical_approx(result - t, digits=4)

    return result


def solve_cvp2(B, t, scale_factors=None, verbose=False):
    """
    A wrapper of `solve_cvp` to perform coordinate scaling.

    Arguments:
        scale_factors: a list of scale factors. The 1st, 2nd, 3rd, ... factor
            will be used for the 1st, 2nd, 3rd, ... coordinate.

    """
    if not scale_factors:
        scale_factors = [1] * B.ncols()

    if verbose:
        print "Scale factors:"
        print numerical_approx(vector(scale_factors), digits=4), '\n'

    scale_matrix = diagonal_matrix(scale_factors)
    return solve_cvp(B*scale_matrix, t*scale_matrix, verbose) * scale_matrix**-1
